#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# Copyright (c) 2023 Mark Documento

from argparse import ArgumentParser
from collections import OrderedDict
from datetime import timedelta
from dateutil import parser
import chardet
import os
import re
import sys

PLAYRES_X = 384
PLAYRES_Y = 288
X_SCALE_FACTOR = 1.0
Y_SCALE_FACTOR = 1.0
DEFAULT_STYLE = OrderedDict([
    ('Name', 'Default'),
    ('Fontname', 'Arial'),
    ('Fontsize', 16),
    ('PrimaryColour', '&Hffffff'),
    ('SecondaryColour', '&Hffffff'),
    ('OutlineColour', '&H0'),
    ('BackColour', '&H0'),
    ('Bold', 0),
    ('Italic', 0),
    ('Underline', 0),
    ('StrikeOut', 0),
    ('ScaleX', 100),
    ('ScaleY', 100),
    ('Spacing', 0),
    ('Angle', 0),
    ('BorderStyle', 1),
    ('Outline', 1),
    ('Shadow', 0),
    ('Alignment', 2),
    ('MarginL', 10),
    ('MarginR', 10),
    ('MarginV', 10),
    ('Encoding', 0)
    ])
LEFT_STYLE = OrderedDict([
    ('Name', 'Left'),
    ('Fontname', 'Arial'),
    ('Fontsize', 16),
    ('PrimaryColour', '&Hffffff'),
    ('SecondaryColour', '&Hffffff'),
    ('OutlineColour', '&H0'),
    ('BackColour', '&H0'),
    ('Bold', 0),
    ('Italic', 0),
    ('Underline', 0),
    ('StrikeOut', 0),
    ('ScaleX', int(100*X_SCALE_FACTOR)),
    ('ScaleY', int(100*Y_SCALE_FACTOR)),
    ('Spacing', 0),
    ('Angle', 0),
    ('BorderStyle', 1),
    ('Outline', 1),
    ('Shadow', 0),
    ('Alignment', 2),
    ('MarginL', 5),
    ('MarginR', (10 + PLAYRES_X)//2),
    ('MarginV', 5),
    ('Encoding', 0)
    ])
RIGHT_STYLE = OrderedDict([
    ('Name', 'Right'),
    ('Fontname', 'Arial'),
    ('Fontsize', 16),
    ('PrimaryColour', '&Hffffff'),
    ('SecondaryColour', '&Hffffff'),
    ('OutlineColour', '&H0'),
    ('BackColour', '&H0'),
    ('Bold', 0),
    ('Italic', 0),
    ('Underline', 0),
    ('StrikeOut', 0),
    ('ScaleX', int(100*X_SCALE_FACTOR)),
    ('ScaleY', int(100*Y_SCALE_FACTOR)),
    ('Spacing', 0),
    ('Angle', 0),
    ('BorderStyle', 1),
    ('Outline', 1),
    ('Shadow', 0),
    ('Alignment', 2),
    ('MarginL', (10 + PLAYRES_X)//2),
    ('MarginR', 5),
    ('MarginV', 5),
    ('Encoding', 0)
    ])       


def read_file(filename):
    try:
        with open(sys.argv[1], 'rb') as f:
            blob = f.read()
            encoding = chardet.detect(blob)
            return blob.decode(encoding['encoding']).split('\n')
    except (UnicodeDecodeError, ValueError):
        raise RuntimeError('Unable to determine file encoding')


def parse_srt(lines):
    start_ts = None
    text = []
    state = 0
    events = []
    for i, line in enumerate(lines):
        line = line.strip()
        if state == 0:
            try:
                _ = re.findall(r'^\d+$', line)[0]
            except IndexError:
                if line:
                    print('Line#', i, line)
                    raise RuntimeError('Incorrect SRT format')
            else:
                state = 1
        elif state == 1:
            try:
                start_ts, end_ts = re.findall(r'^(.+) --> (.+)$', line)[0]
                start_ts = parser.parse(start_ts)
                end_ts = parser.parse(end_ts)
            except (IndexError, parser.ParserError):
                print('Line#', i, line)
                raise RuntimeError('Error parsing timestamps')
            else:
                state = 2
        elif state == 2:
            if not line:
                if not text:
                    print('Line#', i, 'No text in dialogue')
                    #raise RuntimeError('Incorrect SRT format')
                else:
                    events.append((start_ts, end_ts, text))
                    start_ts = None
                    text = []
                    state = 0
            else:
                text.append(re.sub(r'</*[a-zA-Z]+>', '', line))
    if start_ts is not None and text:
        events.append((start_ts, end_ts, text))
    return events


def convert_to_ass(events, is3d=False, shift=0.0,
                   playres_x=PLAYRES_X, playres_y=PLAYRES_Y,
                   default_style=DEFAULT_STYLE,
                   left_style=LEFT_STYLE,
                   right_style=RIGHT_STYLE):
    style = left_style if is3d else default_style
    lines = [
        '[Script Info]',
        '; Script generated by: https://github.com/javelin/srt2ass',
        'ScriptType: v4.00+',
        'PlayResX: {playres_x}'.format(playres_x=playres_x),
        'PlayResY: {playres_y}'.format(playres_y=playres_y),
        'ScaleBorderAndShadow: yes',
        '',
        '[V4+ Styles]',
        'Format: {format}'.format(
            format=', '.join(
                [str(val) for val in style.keys()])),
        'Style: {style}'.format(
            style=','.join(
                [str(val) for val in style.values()]))
    ]
    if is3d:
        lines.append('Style: {style}'.format(
            style=','.join([str(val) for val in right_style.values()])))
    lines.append('')
    lines.append('[Events]')
    lines.append('Format: Layer, Start, End, Style, Name, '
        'MarginL, MarginR, MarginV, Effect, Text')

    if is3d:
        dialogue  = 'Dialogue: 0,{start_ts},{end_ts},Left,,0,0,0,0,{text}\r\n'
        dialogue += 'Dialogue: 0,{start_ts},{end_ts},Right,,0,0,0,0,{text}'
    else:
        dialogue  = 'Dialogue: 0,{start_ts},{end_ts},Default,,0,0,0,0,{text}'

    shift_td = timedelta(seconds=shift)
    lines += [dialogue.format(
                start_ts=(event[0] + shift_td).strftime('%H:%M:%S.%f')[:-4],
                end_ts=(event[1] + shift_td).strftime('%H:%M:%S.%f')[:-4],
                text='\\N'.join(event[2]))
              for event in events]
    return '\r\n'.join(lines)


def parse_args():
    argp = ArgumentParser()
    argp.add_argument('filename', help='Path to SRT file')
    argp.add_argument(
        '-3d', action='store_true',
        dest='_3d',
        default=False,
        help='Create a 3D SBS subtitle (without depth)')
    argp.add_argument(
        '-xs', '--xscale',
        type=float,
        default=X_SCALE_FACTOR,
        help='Horizontal scale factor')
    argp.add_argument(
        '-ys', '--yscale',
        type=float,
        default=Y_SCALE_FACTOR,
        help='Vertical scale factor')
    argp.add_argument(
        '-s', '--shift',
        type=float,
        default=0.0,
        help='Shift time (seconds)')
    return argp.parse_args()


if __name__ == '__main__':
    args = parse_args()
    ##print(args); exit()
    DEFAULT_STYLE['ScaleX'] = int(100*args.xscale)
    DEFAULT_STYLE['ScaleY'] = int(100*args.yscale)
    LEFT_STYLE['ScaleX'] = int(100*args.xscale)
    LEFT_STYLE['ScaleY'] = int(100*args.yscale)
    RIGHT_STYLE['ScaleX'] = int(100*args.xscale)
    RIGHT_STYLE['ScaleY'] = int(100*args.yscale)
    lines = read_file(args.filename)
    events = parse_srt(lines)
    ass = convert_to_ass(events, is3d=args._3d, shift=args.shift)
    ext = '.converted2.3dsbs.ass' if args._3d else '.converted2.ass'
    newfn = os.path.basename(args.filename) + ext
    with open(newfn, 'wt', newline='\r\n') as f:
        f.write(ass)
        print('Converted subtitle saved in', newfn)
